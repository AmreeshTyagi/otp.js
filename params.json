{"name":"otp.js","tagline":"HMAC-based (HOTP) and Time-based (TOTP) One-Time Password manager. Works with Google Authenticator for Two-Factor Authentication.","body":"[![Build Status](https://travis-ci.org/njl07/otp.js.svg)](https://travis-ci.org/njl07/otp.js)\r\n[![Coverage Status](https://coveralls.io/repos/njl07/otp.js/badge.png?branch=master)](https://coveralls.io/r/njl07/otp.js?branch=master)\r\n[![npm version](https://badge.fury.io/js/otp.js.png)](http://badge.fury.io/js/otp.js)\r\n\r\n[![NPM](https://nodei.co/npm/otp.js.png?downloads=true&downloadRank=true&stars=true)](https://nodei.co/npm/otp.js/)\r\n\r\n## One-Time Password manager\r\n\r\nOne Time Password manager is fully compliant with [HOTP](http://tools.ietf.org/html/rfc4226) (counter based one time passwords) and [TOTP](http://tools.ietf.org/html/rfc6238) (time based one time passwords). It can be used in conjunction with the `Google Authenticator`, for Two-Factor Authentication, which has free apps for `iOS`, `Android` and `BlackBerry`.\r\n\r\nAll methods described in both `RFC` are implemented in [API](#api).\r\n\r\n* [Installation](#installation)\r\n* [Getting started](#getting-started)\r\n    * [OTP Generation](#otp-generation)\r\n    * [OTP Verification](#otp-verification)\r\n* [Google Authenticator](#google-authenticator)\r\n    * [Base32 Keys](#base32-keys)\r\n    * [RFC 3548](#rfc-3548)\r\n    * [Code Generation](#code-generation)\r\n    * [Code Verification](#code-verification)\r\n    * [QRCode Generation](#qrcode-generation)\r\n* [API](#api)\r\n    * [HOTP.gen(key, [opt])](#hotpgenkey-opt)\r\n    * [HOTP.verify(token, key, [opt])](#hotpverifytoken-key-opt)\r\n    * [TOTP.gen(key, [opt])](#totpgenkey-opt)\r\n    * [TOTP.verify(token, key, [opt])](#totpverifytoken-key-opt)\r\n    * [GA.encode(secret)](#gaencodesecret)\r\n    * [GA.decode(base32Secret)](#gadecodebase32secret)\r\n    * [GA.secret()](#gasecret)\r\n    * [GA.keyUri(user, issuer, base32Secret)](#gakeyuriuser-issuer-base32secret)\r\n    * [GA.qrCode(user, issuer, base32Secret)](#gaqrcodeuser-issuer-base32secret)\r\n    * [GA.gen(secret)](#gagensecret)\r\n    * [GA.verify(token, secret, [window])](#gaverifytoken-secret-window)\r\n* [Release History](#release-history)\r\n* [License](#license)\r\n\r\n## Installation\r\n\r\nInstall module with: `npm install --save otp.js`\r\n\r\n```javascript\r\nvar OTP = require('otp.js');\r\n```\r\n## Getting started\r\n\r\n```javascript\r\nvar OTP = require('otp.js');\r\n\r\n// get HOTP object\r\nvar HOTP = OTP.hotp;\r\n```\r\n\r\n### OTP Generation\r\n\r\n```javascript\r\ntry\r\n{\r\n    // generate otp for key '12345678901234567890' in string format\r\n    var code = HOTP.gen({string:'12345678901234567890'});\r\n\r\n    console.log(code); // print otp result => 755224\r\n}\r\ncatch(ex)\r\n{\r\n    console.error(ex); // print error occurred during OTP generation process\r\n}\r\n```\r\n\r\n### OTP Verification\r\n\r\n```javascript\r\ntry\r\n{\r\n    // verify otp '755224' for key '12345678901234567890' in string format\r\n    var result = HOTP.verify('755224', {string:'12345678901234567890'});\r\n\r\n    console.log(result); // print result => {delta:{int:0}}\r\n}\r\ncatch(ex)\r\n{\r\n    console.error(ex); // print error occurred during OTP verification process\r\n}\r\n```\r\n\r\n## Google Authenticator\r\n\r\n```javascript\r\nvar OTP = require('otp.js');\r\n\r\n// get GoogleAuthenticator object\r\nvar GA = OTP.googleAuthenticator;\r\n```\r\n\r\n### Base32 Keys\r\n\r\n`Google Authenticator` requires keys to be `base32` encoded.\r\n\r\n### RFC 3548\r\n\r\nGoogle Authenticator requires an [RFC 3548](http://tools.ietf.org/html/rfc3548) compliant encoder.\r\n\r\nOTP calculation will still work should you want to use other `base32` encoding methods (like Crockford's Base 32) but it will NOT be compatible with `Google Authenticator`.\r\n\r\n### Code Generation\r\n\r\n```javascript\r\ntry\r\n{\r\n    // generate otp for base 32 encoded user secret\r\n    var code = GA.gen(GA.encode('base 32 encoded user secret'));\r\n\r\n    console.log(code); // print otp result => 6-digit number\r\n}\r\ncatch(ex)\r\n{\r\n    console.error(ex); // print error occurred during OTP generation process\r\n}\r\n```\r\n\r\n### Code Verification\r\n\r\n```javascript\r\ntry\r\n{\r\n    // verify otp '755224' for base 32 encoded user secret\r\n    var result = GA.verify('XXXXXX', GA.encode('base 32 encoded user secret'));\r\n\r\n    console.log(result); // print result => {delta:#}\r\n}\r\ncatch(ex)\r\n{\r\n    console.error(ex); // print error occurred during OTP verification process\r\n}\r\n```\r\n\r\n### QRCode Generation\r\n\r\n```javascript\r\ntry\r\n{\r\n    // generate base32 secret\r\n    var secret = GA.encode('base 32 encoded user secret') || GA.secret();\r\n\r\n    // get QRCode in SVG format\r\n    var qrCode = GA.qrCode('akanass', 'otp.js', secret);\r\n\r\n    console.log(qrCode); // print svg => <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"215\" height=\"215\" viewBox=\"0 0 43 43\">...</svg>\r\n}\r\ncatch(ex)\r\n{\r\n    console.error(ex); // print error occurred during QRCode generation\r\n}\r\n```\r\n\r\nYou can scan this `qrCode` with your `Google Authenticator` application to show result:\r\n\r\n![QRCode](http://www.otpjs.com/images/qrCode.svg)\r\n\r\n## API\r\n\r\nAll examples assume as base:\r\n\r\n* `var HOTP = require('otp.js').hotp;`\r\n* `var TOTP = require('otp.js').totp;`\r\n* `var GA = require('otp.js').googleAuthenticator;`\r\n\r\n### `HOTP.gen(key, [opt])`\r\n\r\nReturns a counter based one-time password.\r\n\r\n**key**\r\n> Key for the one time password. This should be unique and secret for every user as this is the seed that is used to calculate the HMAC.\r\n> Key is an object with 2 exclusive attributes to define the key's format: `ASCII string` or `Hexadecimal string (>=2-digit)`.\r\n>\r\n> e.g: `{string:'12345678901234567890'}` or `{hex: '3132333435363738393031323334353637383930'}`\r\n\r\n**opt**\r\n> Object option to generate HOTP and can contain the following attributes:\r\n>\r\n> - `counter`: this should be stored by the application, must be user specific, and be incremented for each request.\r\n> Counter is an object with 2 exclusive attributes to define the counter's format: `integer (<=2^53)` or `hexadecimal string (<=16-digit)`.\r\n>> e.g: `{counter:{int:0}}` or `{counter:{hex:'0'}}`\r\n>>\r\n>> Default value is: `{counter:{int:0}}`\r\n>\r\n> - `codeDigits`: the number of digits in the OTP, not including the checksum, if any.\r\n> If you want `6 digits` and you `add checksum`, finally OTP length will be `7 digits`.\r\n>> Default value is: `{codeDigits:6}`\r\n>\r\n> - `addChecksum`: a flag that indicates if a checksum digit should be appended to the OTP.\r\n>> Default value is: `{addChecksum:false}`\r\n>\r\n> - `truncationOffset`: the offset into the MAC result to begin truncation. If this value is out of the range of `0 ... 15`, then dynamic truncation will be used. Dynamic truncation is when the last 4 bits of the last byte of the MAC are used to determine the start offset.\r\n>> Default value is: `undefined` for dynamic truncation\r\n>\r\n> - `algorithm`: the algorithm to create HMAC (`sha1`, `sha256`, `sha512`)\r\n>> Default value is: `sha1`\r\n>\r\n> Finally, `opt` object will be like this:\r\n>> Default value: `{counter:{int:0}, codeDigits:6, addChecksum:false, algorithm:'sha1'}`\r\n\r\n### `HOTP.verify(token, key, [opt])`\r\n\r\nCheck a counter based one time password for validity.\r\n\r\nReturns `null` if token is not valid for given key and options.\r\n\r\nReturns an object `{delta: {int: #}}` or `{delta: {hex: '#'}}`, following counter format, if the token is valid. `delta` is the count skew between client and server.\r\n\r\n**token**\r\n> Passcode to validate\r\n\r\n**key**\r\n> Key for the one time password. This should be unique and secret for every user as this is the seed that is used to calculate the HMAC.\r\n> Key is an object with 2 exclusive attributes to define the key's format: `ASCII string` or `Hexadecimal string (>=2-digit)`.\r\n>\r\n> e.g: `{string:'12345678901234567890'}` or `{hex: '3132333435363738393031323334353637383930'}`\r\n\r\n**opt**\r\n> Object option to verify HOTP and can contain the following attributes:\r\n>\r\n> - `window`: The allowable margin for the counter.  The function will check 'W' codes in the future against the provided passcode.  Note, it is the calling applications responsibility to keep track of 'C' and increment it for each password check, and also to adjust it accordingly in the case where the client and server become out of sync (second argument returns non zero).\r\n>> e.g: if `W = 50`, and `C = 15`, this function will check the passcode against all One Time Passcodes between `15` and `65`.\r\n>>\r\n>> Default value is: `50`\r\n>\r\n> - `counter`: this should be stored by the application, must be user specific, and be incremented for each success request if `delta >= 0`.\r\n> Increment value will be `delta + 1`.\r\n> Counter is an object with 2 exclusive attributes to define the counter's format: `integer (<=2^53)` or `hexadecimal string (<=16-digit)`.\r\n>> e.g: `{counter:{int:0}}` or `{counter:{hex:'0'}}`\r\n>>\r\n>> Default value is: `{counter:{int:0}}`\r\n>\r\n> - `addChecksum`: a flag that indicates if a checksum digit should be appended to the OTP.\r\n>> Default value is: `{addChecksum:false}`\r\n>\r\n> - `truncationOffset`: the offset into the MAC result to begin truncation. If this value is out of the range of `0 ... 15`, then dynamic truncation will be used. Dynamic truncation is when the last 4 bits of the last byte of the MAC are used to determine the start offset.\r\n>> Default value is: `undefined` for dynamic truncation\r\n>\r\n> - `algorithm`: the algorithm to create HMAC (`sha1`, `sha256`, `sha512`)\r\n>> Default value is: `sha1`\r\n>\r\n> - `previousOTPAllowed`: a flag to allow OTP validation before current counter.\r\n>> e.g: if `P = true`, `W = 50`, and `C = 15`, this function will check the passcode against all One Time Passcodes between `0` and `65` because `min` value must be always `>=0`\r\n>>\r\n>> e.g: if `P = true`, `W = 50`, and `C = 150`, this function will check the passcode against all One Time Passcodes between `100` and `200`\r\n>>\r\n>> Default value is: `{previousOTPAllowed:false}`\r\n>\r\n> Finally, `opt` object will be like this:\r\n>> Default value: `{window:50, counter:{int:0}, addChecksum:false, algorithm:'sha1', previousOTPAllowed:false}`\r\n\r\n### `TOTP.gen(key, [opt])`\r\n\r\nReturns a time based one time password.\r\n\r\n**key**\r\n> Key for the one time password. This should be unique and secret for every user as this is the seed that is used to calculate the HMAC.\r\n> Key is an object with 2 exclusive attributes to define the key's format: `ASCII string` or `Hexadecimal string (>=2-digit)`.\r\n>\r\n> e.g: `{string:'12345678901234567890'}` or `{hex: '3132333435363738393031323334353637383930'}`\r\n\r\n**opt**\r\n> Object option to generate TOTP and can contain the following attributes:\r\n>\r\n> - `time`: the time step of the counter in seconds. This must be the same for every request and is used to calculate C.\r\n>> Default value is: `{time:30}`\r\n>\r\n> - `timestamp`: OTP validity timestamp.\r\n>> Default value is: `{timestamp:new Date().getTime()}`\r\n>\r\n> - `codeDigits`: the number of digits in the OTP, not including the checksum, if any.\r\n> If you want `6 digits` and you `add checksum`, finally OTP length will be `7 digits`.\r\n>> Default value is: `{codeDigits:6}`\r\n>\r\n> - `addChecksum`: a flag that indicates if a checksum digit should be appended to the OTP.\r\n>> Default value is: `{addChecksum:false}`\r\n>\r\n> - `truncationOffset`: the offset into the MAC result to begin truncation. If this value is out of the range of `0 ... 15`, then dynamic truncation will be used. Dynamic truncation is when the last 4 bits of the last byte of the MAC are used to determine the start offset.\r\n>> Default value is: `undefined` for dynamic truncation\r\n>\r\n> - `algorithm`: the algorithm to create HMAC (`sha1`, `sha256`, `sha512`)\r\n>> Default value is: `sha1`\r\n>\r\n> Finally, `opt` object will be like this:\r\n>> Default value: `{time:30, timestamp:new Date().getTime(), codeDigits:6, addChecksum:false, algorithm:'sha1'}`\r\n\r\n### `TOTP.verify(token, key, [opt])`\r\n\r\nCheck a time based one time password for validity.\r\n\r\nReturns `null` if token is not valid for given key and options.\r\n\r\nReturns an object `{delta: #}` if the token is valid. `delta` is the count skew between client and server.\r\n\r\n**token**\r\n> Passcode to validate\r\n\r\n**key**\r\n> Key for the one time password. This should be unique and secret for every user as this is the seed that is used to calculate the HMAC.\r\n> Key is an object with 2 exclusive attributes to define the key's format: `ASCII string` or `Hexadecimal string (>=2-digit)`.\r\n>\r\n> e.g: `{string:'12345678901234567890'}` or `{hex: '3132333435363738393031323334353637383930'}`\r\n\r\n**opt**\r\n> Object option to verify HOTP and can contain the following attributes:\r\n>\r\n> - `window`: The allowable margin, time steps in seconds since T0, for the counter.  The function will check 'W' codes in the past and the future against the provided passcode.  Note, it is the calling applications responsibility to keep track of 'C' and increment it for each password check, and also to adjust it accordingly in the case where the client and server become out of sync (second argument returns non zero).\r\n>> e.g: if `W = 5`, and `C = 100`, this function will check the passcode against all One Time Passcodes between `95` and `105`.\r\n>>\r\n>> Default value is: `6`\r\n>\r\n> - `time`: the time step of the counter in seconds. This must be the same for every request and is used to calculate C.\r\n>> Default value is: `{time:30}`\r\n>\r\n> - `timestamp`: OTP validity timestamp.\r\n>> Default value is: `{timestamp:new Date().getTime()}`\r\n>\r\n> - `addChecksum`: a flag that indicates if a checksum digit should be appended to the OTP.\r\n>> Default value is: `{addChecksum:false}`\r\n>\r\n> - `truncationOffset`: the offset into the MAC result to begin truncation. If this value is out of the range of `0 ... 15`, then dynamic truncation will be used. Dynamic truncation is when the last 4 bits of the last byte of the MAC are used to determine the start offset.\r\n>> Default value is: `undefined` for dynamic truncation\r\n>\r\n> - `algorithm`: the algorithm to create HMAC (`sha1`, `sha256`, `sha512`)\r\n>> Default value is: `sha1`\r\n>\r\n> Finally, `opt` object will be like this:\r\n>> Default value: `{window:6, time:30, timestamp:new Date().getTime(), addChecksum:false, algorithm:'sha1'}`\r\n\r\n### `GA.encode(secret)`\r\n\r\nReturns `base32` string.\r\n\r\n**secret**\r\n> Secret to encode\r\n\r\n### `GA.decode(base32Secret)`\r\n\r\nReturns string.\r\n\r\n**base32Secret**\r\n> Secret, to decode, in `base32`\r\n\r\n### `GA.secret()`\r\n\r\nReturns random `16-digit base32` encoded secret.\r\n\r\n### `GA.keyUri(user, issuer, secret)`\r\n\r\nReturns string representation of [key uri](https://code.google.com/p/google-authenticator/wiki/KeyUriFormat): `otpauth://totp/issuer:user@host?secret=xxx&issuer=yyy`\r\n\r\n**user**\r\n> The user for this account.\r\n\r\n**issuer**\r\n> The provider or service managing that account.\r\n\r\n**secret**\r\n> The secret in `base32`. This should be unique and secret for every user as this is the seed that is used to calculate the HMAC.\r\n\r\n### `GA.qrCode(user, issuer, secret)`\r\n\r\nReturns string with image data - `SVG` format.\r\n\r\n**user**\r\n> The user for this account.\r\n\r\n**issuer**\r\n> The provider or service managing that account.\r\n\r\n**secret**\r\n> The secret in `base32`. This should be unique and secret for every user as this is the seed that is used to calculate the HMAC.\r\n\r\n### `GA.gen(secret)`\r\n\r\nReturns a time based one time password.\r\n\r\n**secret**\r\n> The secret in `base32` to generate OTP. This should be unique and secret for every user as this is the seed that is used to calculate the HMAC.\r\n\r\n### `GA.verify(token, secret, [window])`\r\n\r\nCheck a time based one time password for validity.\r\n\r\nReturns `null` if token is not valid for given key and options.\r\n\r\nReturns an object `{delta: #}` if the token is valid. `delta` is the count skew between client and server.\r\n\r\n**token**\r\n> Passcode to validate\r\n\r\n**secret**\r\n> The secret in `base32` to validate OTP. This should be unique and secret for every user as this is the seed that is used to calculate the HMAC.\r\n\r\n**window**\r\n> The allowable margin, time steps in seconds since T0, for the counter.  The function will check 'W' codes in the past and the future against the provided passcode.  Note, it is the calling applications responsibility to keep track of 'C' and increment it for each password check, and also to adjust it accordingly in the case where the client and server become out of sync (second argument returns non zero).\r\n>> e.g: if `W = 5`, and `C = 100`, this function will check the passcode against all One Time Passcodes between `95` and `105`.\r\n>>\r\n>> Default value is: `6`\r\n\r\n## Release History\r\n\r\n| Version    | Notes       |\r\n|:-----------|:------------|\r\n| 1.0.0      | Release Version |\r\n| 0.7.0      | Version with Google Authenticator implementation |\r\n| 0.6.0      | Version with TOTP verification implementation |\r\n| 0.5.1      | Refactor tests - only unit tests |\r\n| 0.5.0      | Option to allow validation for OTP were generated before current counter |\r\n| 0.4.0      | Version with TOTP generation implementation |\r\n| 0.3.0      | Add algorithm choice to generate and verify OTP (sha1, sha256, sha512) |\r\n| 0.2.0      | Version with HOTP verification implementation |\r\n| 0.1.3      | Update unit tests |\r\n| 0.1.2      | Update tests and schemas validation |\r\n| 0.1.1      | Update integration tests |\r\n| 0.1.0      | Version with HOTP generation implementation |\r\n| 0.0.2      | API movement |\r\n| 0.0.1      | First Prototype |\r\n\r\n## License\r\nCopyright (c) 2014 Nicolas Jessel. Licensed under the [MIT license](https://github.com/njl07/otp.js/blob/master/LICENSE.md).","google":"UA-55039120-2","note":"Don't delete this file! It's used internally to help with page regeneration."}